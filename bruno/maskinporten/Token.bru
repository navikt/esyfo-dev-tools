meta {
  name: Token
  type: http
  seq: 1
}

post {
  url: https://test.maskinporten.no/token
  body: formUrlEncoded
  auth: none
}

body:form-urlencoded {
  grant_type: urn:ietf:params:oauth:grant-type:jwt-bearer
  assertion: {{jwt_signed}}
}

script:pre-request {
  const { createSign, randomUUID } = require("crypto");
  
  // Helper: get environment variable (required by default)
  const env = (name, required = true) => {
      const value = bru.getEnvVar(name);
      if (required && !value) throw new Error(`Missing env var '${name}'`);
      return value;
  };
  const authority = "iso6523-actorid-upis";
  const header = { alg: "RS256", kid: env("keyId"), typ: "JWT" };
  const now = Math.floor(Date.now() / 1000);
  
  const payload = {
      aud: "https://test.maskinporten.no/",
      iss: env("clientId"),
      scope: env("scope"),
      iat: now,
      exp: now + 180,
      jti: randomUUID()
  };
  // Sign and set jwt_signed environment variable
  const b64url = (v) => Buffer.from(typeof v === "string" ? v : JSON.stringify(v)).toString("base64url");
  const input = [header, payload].map(b64url).join(".");
  const privateKey  = env("privateKey");
  const sig = createSign("RSA-SHA256").update(input).sign({ key: privateKey }, "base64url");
  
  bru.setEnvVar("jwt_signed", `${input}.${sig}`);
}

settings {
  encodeUrl: true
  timeout: 0
}

docs {
  # Create a plain Maskinporten token 
  
  The token is based on a token exchange, using a private key connected to a Maskinporten-client to sign the claim.
  
  ## Variables used
  
  | Key         | Description                           |
  |-------------|---------------------------------------|
  |privateKey   |PEM used in Maskinporten               |
  |clientId     |The client id connected to Maskinporten|
  |keyId        |The id of the PEM in Maskinporten      |
  |scope        |The scope you want for the token       |
}
